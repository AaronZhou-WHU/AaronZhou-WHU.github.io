<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BinYingの部屋</title>
  
  <subtitle>知之为知之，不知为不知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aaronzhou-whu.github.io/"/>
  <updated>2018-03-12T15:54:17.000Z</updated>
  <id>https://aaronzhou-whu.github.io/</id>
  
  <author>
    <name>Aaron Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo学习笔记（一）</title>
    <link href="https://aaronzhou-whu.github.io/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://aaronzhou-whu.github.io/Dubbo学习笔记（一）/</id>
    <published>2018-03-12T15:54:17.000Z</published>
    <updated>2018-03-12T15:54:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>流式计算框架</title>
    <link href="https://aaronzhou-whu.github.io/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/"/>
    <id>https://aaronzhou-whu.github.io/流式计算框架/</id>
    <published>2018-03-10T14:49:45.000Z</published>
    <updated>2018-03-10T14:49:45.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="https://aaronzhou-whu.github.io/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaronzhou-whu.github.io/消息中间件/</id>
    <published>2018-03-09T15:13:34.000Z</published>
    <updated>2018-03-12T15:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，不同的应用之间需要传递和接收消息（message），消息中间件就是为了解决分布式系统之间的通信。它的异步性方便了对系统进行解耦。<br>在Java邻域，熟知的有JMS（Java Message Service），Java消息服务是一个Java平台中关于面向消息中间件（Message oriented middleware,MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 </p><p>在JMS中，有queue和topic两种模型，点对点（point to point， queue）与发布订阅（publish/subscribe，topic），这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)。</p><p>目前市面上使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。对比如下：<br><img src="http://img.blog.csdn.net/20171027100748177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEyMzYzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>kafka有别于JMS规范或其他分布式消息系统的不同之一，kafka支持将消息持久化处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式系统中，不同的应用之间需要传递和接收消息（message），消息中间件就是为了解决分布式系统之间的通信。它的异步性方便了对系统进行解耦。&lt;br&gt;在Java邻域，熟知的有JMS（Java Message Service），Java消息服务是一个Java平台中关于面向消
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈微服务架构</title>
    <link href="https://aaronzhou-whu.github.io/%E8%B0%88%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://aaronzhou-whu.github.io/谈谈微服务架构/</id>
    <published>2018-03-08T15:30:21.000Z</published>
    <updated>2018-03-08T15:30:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中间件之我的浅显理解</title>
    <link href="https://aaronzhou-whu.github.io/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E6%88%91%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"/>
    <id>https://aaronzhou-whu.github.io/Java中间件之我的浅显理解/</id>
    <published>2018-03-07T15:17:37.000Z</published>
    <updated>2018-03-08T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件（middleware），从字面上来看，是不同的系统或程序之间的中间人，是一种交互媒介（通道），中间件屏蔽了各自的细节，方便不同的系统更加关注于彼此的业务。</p><blockquote><p>百度百科上的解释：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p></blockquote><p>Java中间件常见的三个邻域：</p><blockquote><ul><li>远程过程调用和对象访问中间件</li></ul></blockquote><p>主要解决分布式环境下应用的互相访问问题，这也是支撑应用服务化功能的基础。例如：RPC：Remote Process Call（远程过程调用中间件）</p><blockquote><ul><li>消息中间件</li></ul></blockquote><p>解决应用之间的消息传递、解耦、异步的问题。kafka,activeMQ等。</p><blockquote><ul><li>数据访问中间件</li></ul></blockquote><p>Atlas,Cobar等（mysql数据库）。底层的数据查询过程对于调用者来说是透明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中间件（middleware），从字面上来看，是不同的系统或程序之间的中间人，是一种交互媒介（通道），中间件屏蔽了各自的细节，方便不同的系统更加关注于彼此的业务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百度百科上的解释：中间件是一种独立的系统软件或服务程序，分布式应用软件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异常处理小结</title>
    <link href="https://aaronzhou-whu.github.io/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93/"/>
    <id>https://aaronzhou-whu.github.io/异常处理小结/</id>
    <published>2018-03-06T15:01:12.000Z</published>
    <updated>2018-03-07T11:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>try catch finally语句块中含有return时的执行顺序：finally会在try代码块的return之前执行</p></li><li><p>try中的return如果是普通变量，则finally语句块中对该变量的修改并不会影响到最终的return值；如果是对象类型，则会影响</p></li><li><p>finally中如果有return语句，则会覆盖掉之前的return返回值</p></li><li><p>如果catch块中捕获了异常, 并且在catch块中将该异常throw给上级调用者进行处理, 但finally中return了, 那么catch块中的throw就失效了, 上级方法调用者是捕获不到异常的–<strong>finally中的return会覆盖掉catch中抛出的异常</strong></p></li><li><p>1.6中catch throw e并且函数要throws Exception，而1.8中只需在catch中throw即可</p></li><li><p>参考链接<a href="https://www.jianshu.com/p/36692cb517bc" target="_blank" rel="noopener">https://www.jianshu.com/p/36692cb517bc</a></p></li><li>参考链接<a href="https://www.cnblogs.com/wyisprogramming/p/6610950.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyisprogramming/p/6610950.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;try catch finally语句块中含有return时的执行顺序：finally会在try代码块的return之前执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;try中的return如果是普通变量，则finally语句块中对该变量的修改并不会影响到最终的r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统上程序OOM问题排查与解决方案</title>
    <link href="https://aaronzhou-whu.github.io/linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A8%8B%E5%BA%8FOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://aaronzhou-whu.github.io/linux系统上程序OOM问题排查/</id>
    <published>2018-02-26T15:10:00.000Z</published>
    <updated>2018-03-05T16:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux上的redis服务器，写数据时发现数据写的不完整，很多没写进去，看日子发现报错：SocketException: Broken pipe (Write failed) ，这种错误一般都是redis挂掉了吧，重启redis，重复执行程序，还是会报错，调试代码，运行少量数据（任然是多线程起任务），发现可以完整写入，那应该不是并发的问题，单机redis挂掉，不是因为并发引起的阻塞timeout，那很有可能是空间不足了，毕竟是测试环境，硬件一般。检查redis的配置文件，找到rdb备份文件，du命令查看占用的存储空间，发现果然满了，去/var/log/message下查看系统日志，找到了“kernel: Out of memory: Kill process”字样。</p><p>du命令查看发现home目录空间严重不足，解决方法一是关闭redis持久化，这种方法在实际应用时是不可取的，只是在测试环境中作为一个临时方案；二是把redis的备份文件目录设置到其他大的空间目录下。</p><p>总的来说，单机redis问题多多，稳定性太差，可以使用基于redis集群方案实现的codis。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux上的redis服务器，写数据时发现数据写的不完整，很多没写进去，看日子发现报错：SocketException: Broken pipe (Write failed) ，这种错误一般都是redis挂掉了吧，重启redis，重复执行程序，还是会报错，调试代码，运行少
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式系统简单梳理</title>
    <link href="https://aaronzhou-whu.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/"/>
    <id>https://aaronzhou-whu.github.io/分布式系统简单梳理/</id>
    <published>2018-02-06T15:32:38.000Z</published>
    <updated>2018-02-07T03:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>看我最近总是在念叨什么大数据 云计算 分布式之类的，有天 她突然问我什么是大数据 云计算。当时我只是简单地说了几句，这几天工作之余，再重新翻阅相关书籍，整理了一下，算作是一篇科普博文吧。</p><blockquote><ul><li><strong>大数据：</strong> 这个词语太过于宽泛，很多书上都是讲四个V(Volume,Variety,Value,Velocity),简单地理解，就是大量（海量）数据的存储、计算相关技术的总和。</li><li><strong>云计算：</strong> 云计算建立在分布式计算的基础上，只是把它商业化，对外提供服务，更多的语境上，云计算应该是分布式计算的虚拟化以及服务化（virtualization&amp;service）。</li></ul></blockquote><p>不管是大数据还是云计算，要存储或者计算大量数据，没有分布式技术是很难想象的。并且对于一个对架构感兴趣的Java后台开发人员来说，分布式可是必须掌握的。谈到分布式，就必须说说集群了，感觉他们很像孪生兄弟，在我的记忆中，看的书籍或者博客，凡是谈到分布式的都难免要讲讲集群。</p><p>一个程序（任务）跑在一台机器上，这是我们最熟悉的单机系统。当性能不能满足时，我们会堆积多台机器，这些机器就是集群。把一个任务分拆成很多子任务，把这些子任务分别运行在不同的机器上，这就是分布式。显而易见，分布式技术大大提高了运行效率，这个系统也叫做分布式系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看我最近总是在念叨什么大数据 云计算 分布式之类的，有天 她突然问我什么是大数据 云计算。当时我只是简单地说了几句，这几天工作之余，再重新翻阅相关书籍，整理了一下，算作是一篇科普博文吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大数据：&lt;/str
      
    
    </summary>
    
    
      <category term="Distributed System" scheme="https://aaronzhou-whu.github.io/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://aaronzhou-whu.github.io/hello-world/"/>
    <id>https://aaronzhou-whu.github.io/hello-world/</id>
    <published>2018-02-02T15:48:18.000Z</published>
    <updated>2018-02-05T14:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://aaronzhou-whu.github.io/">BinYingの部屋</a>！以前很懒，看过的东西不加总结，时间长了就忘记了，是时候养成写博文的习惯，毕竟好记忆不如烂笔头。 记录自己的学习过程，顺便能与其他人交流，如果能给刚入门的学习者提供帮助的话，那就再好不过了，通往大牛的路上没有终点，顽张れ… </p><p>####知之为知之，不知为不知</p><p>supercalifragilisticexpialidocious</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://aaronzhou-whu.github.io/&quot;&gt;BinYingの部屋&lt;/a&gt;！以前很懒，看过的东西不加总结，时间长了就忘记了，是时候养成写博文的习惯，毕竟好记忆不如烂笔头。 记录自己的学习过程，顺便能与其他人交流，
      
    
    </summary>
    
    
  </entry>
  
</feed>

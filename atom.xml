<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BinYingの部屋</title>
  
  <subtitle>知之为知之，不知为不知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aaronzhou-whu.github.io/"/>
  <updated>2018-04-02T16:05:37.000Z</updated>
  <id>https://aaronzhou-whu.github.io/</id>
  
  <author>
    <name>Aaron Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的几种概率名词</title>
    <link href="https://aaronzhou-whu.github.io/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A6%82%E7%8E%87%E5%90%8D%E8%AF%8D/"/>
    <id>https://aaronzhou-whu.github.io/常见的几种概率名词/</id>
    <published>2018-04-02T16:02:23.000Z</published>
    <updated>2018-04-02T16:05:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>先验概率，后验概率，似然概率，条件概率，贝叶斯，最大似然<br>总是容易搞混，这里总结一下常规的叫法：</p><p><strong>先验概率：</strong><br>事件发生前的预判概率。可以是基于历史数据的统计，可以由背景常识得出，也可以是人的主观观点给出。一般都是单独事件概率，如P(x),P(y)。</p><p><strong>后验概率：</strong><br>事件发生后求的反向条件概率；或者说，基于先验概率求得的反向条件概率。概率形式与条件概率相同。</p><p><strong>条件概率：</strong><br>一个事件发生后另一个事件发生的概率。一般的形式为P(x|y)表示y发生的条件下x发生的概率。</p><p><strong>贝叶斯公式：</strong><br>P(y|x) = ( P(x|y) * P(y) ) / P(x)</p><p>这里：<br>P(y|x) 是后验概率，一般是我们求解的目标。</p><p>P(x|y) 是条件概率，又叫似然概率，一般是通过历史数据统计得到。一般不把它叫做先验概率，但从定义上也符合先验定义。</p><p>P(y) 是先验概率，一般都是人主观给出的。贝叶斯中的先验概率一般特指它。</p><p>P(x) 其实也是先验概率，只是在贝叶斯的很多应用中不重要（因为只要最大后验不求绝对值），需要时往往用全概率公式计算得到。</p><p>实例：假设y是文章种类，是一个枚举值；x是向量，表示文章中各个单词的出现次数。</p><p>在拥有训练集的情况下，显然除了后验概率P(y|x)中的x来自一篇新文章无法得到，p(x),p(y),p(x|y)都是可以在抽样集合上统计出的。</p><p><strong>最大似然理论：</strong></p><p>认为P(x|y)最大的类别y，就是当前文档所属类别。即Max P(x|y) = Max p(x1|y)<em>p(x2|y)</em>…p(xn|y), for all y</p><p><strong>贝叶斯理论：</strong></p><p>认为需要增加先验概率p(y)，因为有可能某个y是很稀有的类别几千年才看见一次，即使P(x|y)很高，也很可能不是它。</p><p>所以y = Max P(x|y) * P(y), 其中p(y)一般是数据集里统计出来的。</p><p>从上例来讲，贝叶斯理论显然更合理一些；但实际中很多先验概率是拍脑袋得出的（不准），有些甚至是为了方便求解方便生造出来的（硬凑），那有先验又有什么好处呢？一般攻击贝叶斯都在于这一点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先验概率，后验概率，似然概率，条件概率，贝叶斯，最大似然&lt;br&gt;总是容易搞混，这里总结一下常规的叫法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先验概率：&lt;/strong&gt;&lt;br&gt;事件发生前的预判概率。可以是基于历史数据的统计，可以由背景常识得出，也可以是人的主观观点给出。一般都是单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一致性哈希</title>
    <link href="https://aaronzhou-whu.github.io/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <id>https://aaronzhou-whu.github.io/一致性哈希/</id>
    <published>2018-03-28T05:35:08.000Z</published>
    <updated>2018-03-28T05:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>均衡性：哈希的结果能够尽可能分布到所有的缓存中去。</p><p>单调性：当缓冲区大小变化时一致性哈希尽量保护已分配的内容不会被重新映射到新缓冲区。</p><p>分散性：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。</p><p>负载：另一个维度的分散性问题，对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。</p><p>首先，求出每个服务器的hash值，将其配置到一个 0~2^n 的圆环上（n通常取32）；<br>其次，用同样的方法求出待存储对象的主键 hash值，也将其配置到这个圆环上；<br>再次，从数据映射到的位置开始顺时针查找，将数据分布到找到的第一个服务器节点上。一致性hash的优点在于加入和删除节点时只会影响到在哈希还种相邻的节点，而对其他节点没有影响。</p><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。hash 算法并不是保证绝对的平衡，<br>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：<br>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p><p>ps:摘选自网上很多blog，谢谢他们！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;均衡性：哈希的结果能够尽可能分布到所有的缓存中去。&lt;/p&gt;
&lt;p&gt;单调性：当缓冲区大小变化时一致性哈希尽量保护已分配的内容不会被重新映射到新缓冲区。&lt;/p&gt;
&lt;p&gt;分散性：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>流式计算框架--Storm</title>
    <link href="https://aaronzhou-whu.github.io/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6-Storm/"/>
    <id>https://aaronzhou-whu.github.io/流式计算框架-Storm/</id>
    <published>2018-03-16T07:50:46.000Z</published>
    <updated>2018-03-16T08:23:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Storm是一个分布式的，可靠的，容错的数据流处理系统。它是一个流式计算框架，时延低，无状态的，它通过Apache ZooKeeper管理分布式环境和集群状态，适合实时计算。</p><p>Apache Storm的组件：<br>| 组件 | 描述 |<br>| :-: |  |<br>| Tuple     | 它是有序元素的列表，一组逗号分隔的值，Tuple支持所有数据类型，并传递到Storm集群 |<br>| Stream        |   流是元组的无序序列  |<br>| Spouts        |   Storm从原始数据源（如 Kafka队列，Kestrel队列等）接受输入数据  |<br>| Bolts        |Bolts是逻辑处理单元，接收spout的输入，并产生新的数据流   |</p><p>Storm集群概念：<br>| 组件 | 描述 |<br>| :- | :- |<br>|Nimbus（主节点）|    Nimbus是Storm集群的主节点。集群中的所有其他节点称为工作节点。主节点负责在所有工作节点之间分发数据，向工作节点分配任务和监视故障。|<br>|Supervisor（工作节点）|    遵循指令的节点被称为Supervisors。Supervisor有多个工作进程，它管理工作进程以完成由nimbus分配的任务。|<br>|Worker process（工作进程）|    工作进程将执行与特定拓扑相关的任务。工作进程不会自己运行任务，而是创建执行器并要求他们执行特定的任务。工作进程将有多个执行器。|<br>|Executor（执行者）|执行器只是工作进程产生的单个线程。执行器运行一个或多个任务，但仅用于特定的spout或bolt。|<br>|Task（任务）|任务执行实际的数据处理。所以，它是一个spout或bolt。|<br>|ZooKeeper framework（ZooKeeper框架）|Apache的ZooKeeper的是使用群集（节点组）自己和维护具有强大的同步技术共享数据之间进行协调的服务。Nimbus是无状态的，所以它依赖于ZooKeeper来监视工作节点的状态。ZooKeeper的帮助supervisor与nimbus交互。它负责维持nimbus，supervisor的状态。|</p><p>Apache Storm的工作流程 −</p><ol><li>nimbus接收到提交的“Storm拓扑”，并将任务分配给所有的supervisors</li><li>在特定的时间间隔，所有supervisor将向nimbus发送心跳以通知它们仍然运行着。</li><li>当nimbus检测不到supervisor的心跳时，会将任务分配给另一个supervisor。</li><li>当nimbus本身终止时，supervisor将在没有任何问题的情况下对已经分配的任务进行工作。</li><li>一旦所有的任务都完成后，supervisor将等待新的任务进去；同时，nimbus将由服务监控工具自动重新启动。</li><li>由于网络管理程序和supervisor都可以自动重新启动，并且两者将像以前一样继续，因此Storm保证至少处理所有任务一次。</li><li>一旦处理了所有拓扑，则网络管理器等待新的拓扑到达，并且类似地，管理器等待新的任务。</li></ol><p>默认情况下，Storm集群中有两种模式：</p><blockquote><ul><li>本地模式 -此模式用于开发，测试和调试，因为它是查看所有拓扑组件协同工作的最简单方法。在这种模式下，我们可以调整参数，使我们能够看到我们的拓扑如何在不同的Storm配置环境中运行。在本地模式下，storm拓扑在本地机器上在单个JVM中运行。</li><li>生产模式 -在这种模式下，我们将拓扑提交到工作Storm集群，该集群由许多进程组成，通常运行在不同的机器上。如在storm的工作流中所讨论的，工作集群将无限地运行，直到它被关闭。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Storm是一个分布式的，可靠的，容错的数据流处理系统。它是一个流式计算框架，时延低，无状态的，它通过Apache ZooKeeper管理分布式环境和集群状态，适合实时计算。&lt;/p&gt;
&lt;p&gt;Apache Storm的组件：&lt;br&gt;| 组件 | 描述 |&lt;br&gt;| :-: |
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dubbo学习笔记（一）</title>
    <link href="https://aaronzhou-whu.github.io/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://aaronzhou-whu.github.io/Dubbo学习笔记（一）/</id>
    <published>2018-03-12T15:54:17.000Z</published>
    <updated>2018-03-12T15:54:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据处理框架简介</title>
    <link href="https://aaronzhou-whu.github.io/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/"/>
    <id>https://aaronzhou-whu.github.io/流式计算框架/</id>
    <published>2018-03-10T14:49:45.000Z</published>
    <updated>2018-03-16T07:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据处理框架比较常见的又hadoop、spark以及storm。Hadoop是基于HDFS的，数据都存储在磁盘上，io开销比较大；storm是基于内存的，使用zeroMQ消息中间件传递消息，速度比较快。</p><blockquote><ul><li>Hadoop M/R基于HDFS，需要切分输入数据、产生中间数据文件、排序、数据压缩、多份复制等，效率较低。</li><li>Storm 基于ZeroMQ高性能的消息中间件，不持久化数据，效率高。</li><li>Spark基于Map Reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点，但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的Map Reduce的算法</li></ul></blockquote><p>Hadoop适合于离线的批量数据处理适用于对实时性要求极低的场景;Storm适合于实时流数据处理，实时性方面做得极好;Spark介于二者之间，批处理方面性能优于Map-Reduce，（Spark streaming）流处理目前弱于Storm。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大数据处理框架比较常见的又hadoop、spark以及storm。Hadoop是基于HDFS的，数据都存储在磁盘上，io开销比较大；storm是基于内存的，使用zeroMQ消息中间件传递消息，速度比较快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hadoop M
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="https://aaronzhou-whu.github.io/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaronzhou-whu.github.io/消息中间件/</id>
    <published>2018-03-09T15:13:34.000Z</published>
    <updated>2018-03-12T15:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，不同的应用之间需要传递和接收消息（message），消息中间件就是为了解决分布式系统之间的通信。它的异步性方便了对系统进行解耦。<br>在Java邻域，熟知的有JMS（Java Message Service），Java消息服务是一个Java平台中关于面向消息中间件（Message oriented middleware,MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 </p><p>在JMS中，有queue和topic两种模型，点对点（point to point， queue）与发布订阅（publish/subscribe，topic），这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)。</p><p>目前市面上使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。对比如下：<br><img src="http://img.blog.csdn.net/20171027100748177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEyMzYzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>kafka有别于JMS规范或其他分布式消息系统的不同之一，kafka支持将消息持久化处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式系统中，不同的应用之间需要传递和接收消息（message），消息中间件就是为了解决分布式系统之间的通信。它的异步性方便了对系统进行解耦。&lt;br&gt;在Java邻域，熟知的有JMS（Java Message Service），Java消息服务是一个Java平台中关于面向消
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈微服务架构</title>
    <link href="https://aaronzhou-whu.github.io/%E8%B0%88%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://aaronzhou-whu.github.io/谈谈微服务架构/</id>
    <published>2018-03-08T15:30:21.000Z</published>
    <updated>2018-03-16T09:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中间件之我的浅显理解</title>
    <link href="https://aaronzhou-whu.github.io/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E6%88%91%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"/>
    <id>https://aaronzhou-whu.github.io/Java中间件之我的浅显理解/</id>
    <published>2018-03-07T15:17:37.000Z</published>
    <updated>2018-03-08T13:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件（middleware），从字面上来看，是不同的系统或程序之间的中间人，是一种交互媒介（通道），中间件屏蔽了各自的细节，方便不同的系统更加关注于彼此的业务。</p><blockquote><p>百度百科上的解释：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p></blockquote><p>Java中间件常见的三个邻域：</p><blockquote><ul><li>远程过程调用和对象访问中间件</li></ul></blockquote><p>主要解决分布式环境下应用的互相访问问题，这也是支撑应用服务化功能的基础。例如：RPC：Remote Process Call（远程过程调用中间件）</p><blockquote><ul><li>消息中间件</li></ul></blockquote><p>解决应用之间的消息传递、解耦、异步的问题。kafka,activeMQ等。</p><blockquote><ul><li>数据访问中间件</li></ul></blockquote><p>Atlas,Cobar等（mysql数据库）。底层的数据查询过程对于调用者来说是透明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中间件（middleware），从字面上来看，是不同的系统或程序之间的中间人，是一种交互媒介（通道），中间件屏蔽了各自的细节，方便不同的系统更加关注于彼此的业务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百度百科上的解释：中间件是一种独立的系统软件或服务程序，分布式应用软件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异常处理小结</title>
    <link href="https://aaronzhou-whu.github.io/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93/"/>
    <id>https://aaronzhou-whu.github.io/异常处理小结/</id>
    <published>2018-03-06T15:01:12.000Z</published>
    <updated>2018-03-07T11:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>try catch finally语句块中含有return时的执行顺序：finally会在try代码块的return之前执行</p></li><li><p>try中的return如果是普通变量，则finally语句块中对该变量的修改并不会影响到最终的return值；如果是对象类型，则会影响</p></li><li><p>finally中如果有return语句，则会覆盖掉之前的return返回值</p></li><li><p>如果catch块中捕获了异常, 并且在catch块中将该异常throw给上级调用者进行处理, 但finally中return了, 那么catch块中的throw就失效了, 上级方法调用者是捕获不到异常的–<strong>finally中的return会覆盖掉catch中抛出的异常</strong></p></li><li><p>1.6中catch throw e并且函数要throws Exception，而1.8中只需在catch中throw即可</p></li><li><p>参考链接<a href="https://www.jianshu.com/p/36692cb517bc" target="_blank" rel="noopener">https://www.jianshu.com/p/36692cb517bc</a></p></li><li>参考链接<a href="https://www.cnblogs.com/wyisprogramming/p/6610950.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyisprogramming/p/6610950.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;try catch finally语句块中含有return时的执行顺序：finally会在try代码块的return之前执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;try中的return如果是普通变量，则finally语句块中对该变量的修改并不会影响到最终的r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统上程序OOM问题排查与解决方案</title>
    <link href="https://aaronzhou-whu.github.io/linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A8%8B%E5%BA%8FOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://aaronzhou-whu.github.io/linux系统上程序OOM问题排查/</id>
    <published>2018-02-26T15:10:00.000Z</published>
    <updated>2018-03-05T16:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux上的redis服务器，写数据时发现数据写的不完整，很多没写进去，看日子发现报错：SocketException: Broken pipe (Write failed) ，这种错误一般都是redis挂掉了吧，重启redis，重复执行程序，还是会报错，调试代码，运行少量数据（任然是多线程起任务），发现可以完整写入，那应该不是并发的问题，单机redis挂掉，不是因为并发引起的阻塞timeout，那很有可能是空间不足了，毕竟是测试环境，硬件一般。检查redis的配置文件，找到rdb备份文件，du命令查看占用的存储空间，发现果然满了，去/var/log/message下查看系统日志，找到了“kernel: Out of memory: Kill process”字样。</p><p>du命令查看发现home目录空间严重不足，解决方法一是关闭redis持久化，这种方法在实际应用时是不可取的，只是在测试环境中作为一个临时方案；二是把redis的备份文件目录设置到其他大的空间目录下。</p><p>总的来说，单机redis问题多多，稳定性太差，可以使用基于redis集群方案实现的codis。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux上的redis服务器，写数据时发现数据写的不完整，很多没写进去，看日子发现报错：SocketException: Broken pipe (Write failed) ，这种错误一般都是redis挂掉了吧，重启redis，重复执行程序，还是会报错，调试代码，运行少
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式系统简单梳理</title>
    <link href="https://aaronzhou-whu.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/"/>
    <id>https://aaronzhou-whu.github.io/分布式系统简单梳理/</id>
    <published>2018-02-06T15:32:38.000Z</published>
    <updated>2018-02-07T03:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>看我最近总是在念叨什么大数据 云计算 分布式之类的，有天 她突然问我什么是大数据 云计算。当时我只是简单地说了几句，这几天工作之余，再重新翻阅相关书籍，整理了一下，算作是一篇科普博文吧。</p><blockquote><ul><li><strong>大数据：</strong> 这个词语太过于宽泛，很多书上都是讲四个V(Volume,Variety,Value,Velocity),简单地理解，就是大量（海量）数据的存储、计算相关技术的总和。</li><li><strong>云计算：</strong> 云计算建立在分布式计算的基础上，只是把它商业化，对外提供服务，更多的语境上，云计算应该是分布式计算的虚拟化以及服务化（virtualization&amp;service）。</li></ul></blockquote><p>不管是大数据还是云计算，要存储或者计算大量数据，没有分布式技术是很难想象的。并且对于一个对架构感兴趣的Java后台开发人员来说，分布式可是必须掌握的。谈到分布式，就必须说说集群了，感觉他们很像孪生兄弟，在我的记忆中，看的书籍或者博客，凡是谈到分布式的都难免要讲讲集群。</p><p>一个程序（任务）跑在一台机器上，这是我们最熟悉的单机系统。当性能不能满足时，我们会堆积多台机器，这些机器就是集群。把一个任务分拆成很多子任务，把这些子任务分别运行在不同的机器上，这就是分布式。显而易见，分布式技术大大提高了运行效率，这个系统也叫做分布式系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看我最近总是在念叨什么大数据 云计算 分布式之类的，有天 她突然问我什么是大数据 云计算。当时我只是简单地说了几句，这几天工作之余，再重新翻阅相关书籍，整理了一下，算作是一篇科普博文吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大数据：&lt;/str
      
    
    </summary>
    
    
      <category term="Distributed System" scheme="https://aaronzhou-whu.github.io/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://aaronzhou-whu.github.io/hello-world/"/>
    <id>https://aaronzhou-whu.github.io/hello-world/</id>
    <published>2018-02-02T15:48:18.000Z</published>
    <updated>2018-02-05T14:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://aaronzhou-whu.github.io/">BinYingの部屋</a>！以前很懒，看过的东西不加总结，时间长了就忘记了，是时候养成写博文的习惯，毕竟好记忆不如烂笔头。 记录自己的学习过程，顺便能与其他人交流，如果能给刚入门的学习者提供帮助的话，那就再好不过了，通往大牛的路上没有终点，顽张れ… </p><p>####知之为知之，不知为不知</p><p>supercalifragilisticexpialidocious</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://aaronzhou-whu.github.io/&quot;&gt;BinYingの部屋&lt;/a&gt;！以前很懒，看过的东西不加总结，时间长了就忘记了，是时候养成写博文的习惯，毕竟好记忆不如烂笔头。 记录自己的学习过程，顺便能与其他人交流，
      
    
    </summary>
    
    
  </entry>
  
</feed>
